import numpy as np

def calculate_P(t, delta_D, U, I, N, U_mean, I_mean, alpha=0.5, beta=0.3, lambda_=0.1, T=10, detailed=False):
    """Calculate probability of destructive impulse P for an edge.
    Args:
        t: Time array
        delta_D, U, I, N: Arrays/floats for trust change, satisfaction, impulsivity, network influence
        U_mean, I_mean: Baseline values
        alpha, beta, lambda_, T: Model parameters
        detailed: If True, return contributions
    Returns:
        float (P) or dict (P and contributions)
    """
    if len(t) != len(delta_D) or len(t) != len(U) or len(t) != len(I) or len(t) != len(N):
        raise ValueError("Input arrays must have the same length")
    decay = np.exp(-lambda_ * (T - t))
    delta_D_term = delta_D
    U_I_term = alpha * (U / U_mean) * (I / I_mean)
    N_term = beta * N
    integrand = delta_D_term + U_I_term + N_term
    P = np.trapz(integrand * decay, t)
    if detailed:
        return {
            'P': P,
            'contributions': {
                'delta_D': np.trapz(delta_D_term * decay, t),
                'U_I': np.trapz(U_I_term * decay, t),
                'N': np.trapz(N_term * decay, t)
            }
        }
    return P

def generate_synthetic_data(n_nodes, T=10):
    """Generate synthetic data for U, I, delta_D, N."""
    t = np.linspace(0, T, 100)
    U = np.random.normal(0.5, 0.1, n_nodes)
    I = np.random.gamma(2, 0.2, n_nodes)
    delta_D = np.cumsum(np.random.normal(0, 0.05, n_nodes))
    N = np.full(n_nodes, 0.5)  # Placeholder for graph-based N
    return t, U, I, delta_D, N

def scenario_supportive_network(graph, node_a, node_b, t, U_mean, I_mean):
    """Scenario: Conflict with supportive network."""
    edge = graph[node_a][node_b]
    edge['delta_D'] = np.full(len(t), -0.2)
    edge['U'] = np.full(len(t), 0.4)
    edge['I'] = np.full(len(t), 0.8)
    edge['N'] = np.full(len(t), 0.7)
    edge['P'] = calculate_P(t, edge['delta_D'], edge['U'], edge['I'], edge['N'], U_mean, I_mean, detailed=True)
    return graph

def scenario_isolated_threat(graph, node_a, node_b, t, U_mean, I_mean):
    """Scenario: Isolated threat with low N(t)."""
    edge = graph[node_a][node_b]
    edge['delta_D'] = np.full(len(t), -0.3)
    edge['U'] = np.full(len(t), 0.3)
    edge['I'] = np.full(len(t), 0.9)
    edge['N'] = np.full(len(t), 0.2)
    edge['P'] = calculate_P(t, edge['delta_D'], edge['U'], edge['I'], edge['N'], U_mean, I_mean, detailed=True)
    return graph

def scenario_chaotic_pulse(graph, node_d, t, U_mean, I_mean):
    """Scenario: Chaotic impulse with wave propagation."""
    graph.nodes[node_d]['I'] = np.random.uniform(0.2, 0.9, len(t))
    for neighbor in graph.neighbors(node_d):
        edge = graph[node_d][neighbor]
        edge['P'] = calculate_P(t, edge['delta_D'], edge['U'], edge['I'], edge['N'], U_mean, I_mean, detailed=True)
        if edge['P'] > 0.7:  # Propagate wave
            edge['I'] += 0.1
            if graph.degree(neighbor) > 5:  # Hub amplification
                edge['P']['P'] *= 1.2
    return graph